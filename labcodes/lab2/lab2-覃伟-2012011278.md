# lab2 report 计22班 覃伟 2012011278

## 练习1 实现 first-fit 连续物理内存分配算法（需要编程）

> 
实现first-fit算法，需要对default_init,default_init_memmap,default_alloc_pages, default_free_pages这4个函数进行修改重写。      
其中有一个free_area_t结构的变量free_area对空间进行管理，结构中有一个list用于表示空闲块，有一个数字表示空闲块的数量。     
1. default_init：对free_area进行初始化，init该list，并先将空闲块数置为0，完成初始化的代码不需要修改。     
2. default_init_memmap：对传入的参数(页开始地址base，页面数量n)进行内存块的初始化的划分，对每个页进行初始化（这里每页大小为1）：     
	(1)用SetPageProperty函数将页面的flag设置PG_property(第1位)为1，表明该页有效。       
	(2)若页空闲，并且不是第一页，将property设置为0。     
	(3)若页空闲，并且是第一页，将property设置为页面的数量（传入的参数n）。       
	(4)用set_page_ref函数将页的ref设为0，表明该页空闲并且没有引用。     
	(5)用list_add_before函数将该页插入到list的前面（因为是头尾相连的双向链表，所以加到header前面表示加到了list的最末尾）。     
	(6)更新空闲块数为n。     
3. default_alloc_pages：为需要内存空闲为传入参数n的进程分配空间。     
	(1)先判断剩余的空间是否比需要的大，若小于需要的空间，则返回NULL。      
	(2)剩余空间足够，则对list进行遍历，寻找满足大小的块。     
	(3)若遍历一遍后找不到，返回NULL。     
	(4)遍历中找到了符合大小的块p，则先对p开始的n个小块进行处理：     
	     用SetPageReserved与ClearPageProperty设置PG_reserved（第0位）=1, PG_property（第1位）=0，然后将相应的节点从list中删去。     
		 若p的大小大于n(而不是恰好等于)，则需要更新该块的大小：(e2page(le,page_link))->property = p->property - n；     
		 重新计算所有剩余的空闲块：nr_free -= n；      
		 然后返回p的地址。      
4. default_free_pages：对(地址为base，大小为n的)空间进行释放并合并。     
	(1)先根据base对list进行遍历找到比base大的地址的块。     
	(2)将该n个页插回到list中。     
	(3)重设base页的属性ref,flags,property。     
	(4)对空间进行合并，先向前合并，然后向后合并。      
在参考了答案以后，发现答案中有许多重复的对属性的设定，比如：     
1. default_alloc_pages中，对分配出去的n个块（包括base那块）进行了设置属性flags的处理，之后又对base设置flags，重复了；     
2. default_free_pages中，将n个页面插入之后，要对base的属性flags进行设置，先设为0，然后用ClearPageProperty将PG_property设为0，又用SetPageProperty将PG_property设为1，只需要后一个即可。     

### 与标准答案的区别
参考代码中的注释部分进行函数的修改，因此结构上与标准答案差异不是很大。        
另外，标准答案中有许多地方看起来重复且没有作用，我在深入理解的基础上（因此代码中有较多的注释）进行了简化。       
同时我使用了一些中间变量，使结构更清晰。     

### 问答题
你的first fit算法是否有进一步的改进空间	     
> 有改进的空间，比如可以不必要对每一个地址空间设置一个list项，而是连续的一块地址空间设置一个list项，一开始只有一项，即为总的空间。     


## 练习2 实现寻找虚拟地址对应的页表项
> 
1. 通过PDX(la)得到线性地址的在PDE中的index，然后通过&pgdir[PDX(la)]得到该地址的pde；     
2. 通过与PTE_P(0x001)按位与判断该条pde是否存在；     
3. 如果pde不存在，则通过create判断是否需要为其分配空间，若不需要分配或者分配失败，返回NULL，表明该页表项不存在；     
4. 通过set_page_ref设置页的引用为1；     
5. 用page2pa函数得到页对应的物理地址；       
6. 用memset(开始地址，设置的内容，设置的长度)函数对页中的内容进行清除，其中页的长度为PGSIZE：4096；     
7. 设置pde的3个标志位为：存在、可写、用户可操作；     
8. 返回pte。     

### 与标准答案的区别
根据注释的步骤进行编程，与标准答案结构逻辑上基本一致，但实现有所差异。        
在进行if语句的判断时，我是一步步进行判断，这样不容易出错；而标准答案则是一步到位：if (!create || (page = alloc_page()) == NULL)       
同时我使用了一些中间变量，使结构更清晰。     

### 问答题
#### 1. 请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。 
1. PDE与PTE的组成相同：       
	末位：PTE_P:存在位，表示是否缺页      
	倒数第2位：PTE_W：是否可写      
	倒数第3位：PTE_U：用户可操作      
	倒数第4位：PTE_PWT：是否是Write-Through策略     
	倒数第5位：PTE_PCD：Cache是否开启         
	倒数第6位：PTE_A：是否为最近访问，用于cache替换策略          
	倒数第7位：PTE_D：是否为脏的（修改过）     
	倒数第8位：PTE_PS：页大小     
	倒数第8、9位：PTE_MBZ：必须为0      
	倒数第10--12位：PTE_AVAIL：软件可用      
	高20位：下一级使用的地址的高20位      
2. 用处：用于从虚拟地址转换到物理地址，根据32位的逻辑地址，取高10位作为页目录项的index，然后从PDE中取得PTE地址的高20位；      
这20位的高地址与逻辑地址的第21到12位组合得到需要的PTE的地址，从中取得高20位作为物理地址的高20位；      
然后这高20位地址与逻辑地址的最低12位组合得到准确的物理地址。

#### 2. 如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情。      
> 出现了页访问异常，则会产生中断，保存一些寄存器的值（如产生异常的线性地址、CS、EIP等），然后转到内核态进行处理，处理好之后进行恢复。     


## 练习3 释放某虚地址所在的页并取消对应二级页表项的映射
>
1. 通过与PTE_P(0x001)按位与判断该条pte是否存在；       
2. 若存在，则通过pte2page函数得到对应的页的地址；      
3. 用page_ref_dec函数对该页的引用次数减1，这个函数的返回值是引用次数减1后的数值；     
4. 若返回值为0，则需要用free_page函数将该页释放；      
5. 将该二级页表项的映射清楚（设为0即可）；      
6. 用tlb_invalidate函数更新TLB表。

### 与标准答案的区别
根据注释的步骤进行编程，与标准答案结构逻辑上基本一致，但实现有所差异。        
同时使用了一些中间变量，使结构更清晰。       

### 问答题
1. 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？     
> 有对应关系。     
每一个页的大小是4096(#define PGSIZE 4096，也就是2^12)，因此物理地址右移12位就是相应的页的序号，也就是对应的全局变量Page数组中的项。     
而PDE与PTE的高20位就是下一级要寻找地址的高20位，因此这高20位就对应着页的序号，因此(PDE或PTE)>>12即为页序号，以此为下标从Page数组中找到的即为需要的页。      
总而言之，(PDE或PTE)>>12即为页序号，对应Page数组中该下标的项。

2. 如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？    
> 放弃页机制即可。
